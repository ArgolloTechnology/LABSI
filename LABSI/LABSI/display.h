#include <avr/io.h>
#define F_CPU 16000000UL
#include <util/delay.h>

#define SCL_CLOCK 100000UL  // Frequência I2C (100 kHz)
#define OLED_ADDRESS 0x3C  // Endereço I2C do SSD1306

const uint8_t font5x7[] = {
	// Espaço e símbolos ASCII 32-47
	0x00, 0x00, 0x00, 0x00, 0x00,  // ' ' (32)
	0x00, 0x00, 0x5F, 0x00, 0x00,  // '!' (33)
	0x00, 0x07, 0x00, 0x07, 0x00,  // '"' (34)
	0x14, 0x7F, 0x14, 0x7F, 0x14,  // '#' (35)
	0x24, 0x2A, 0x7F, 0x2A, 0x12,  // '$' (36)
	0x23, 0x13, 0x08, 0x64, 0x62,  // '%' (37)
	0x36, 0x49, 0x55, 0x22, 0x50,  // '&' (38)
	0x00, 0x05, 0x03, 0x00, 0x00,  // ''' (39)
	0x00, 0x1C, 0x22, 0x41, 0x00,  // '(' (40)
	0x00, 0x41, 0x22, 0x1C, 0x00,  // ')' (41)
	0x14, 0x08, 0x3E, 0x08, 0x14,  // '*' (42)
	0x08, 0x08, 0x3E, 0x08, 0x08,  // '+' (43)
	0x00, 0x50, 0x30, 0x00, 0x00,  // ',' (44)
	0x08, 0x08, 0x08, 0x08, 0x08,  // '-' (45)
	0x00, 0x60, 0x60, 0x00, 0x00,  // '.' (46)
	0x20, 0x10, 0x08, 0x04, 0x02,  // '/' (47)
	
	// Dígitos ASCII 48-57 ('0' - '9')
	0x3E, 0x51, 0x49, 0x45, 0x3E,  // '0' (48)
	0x00, 0x42, 0x7F, 0x40, 0x00,  // '1' (49)
	0x42, 0x61, 0x51, 0x49, 0x46,  // '2' (50)
	0x21, 0x41, 0x45, 0x4B, 0x31,  // '3' (51)
	0x18, 0x14, 0x12, 0x7F, 0x10,  // '4' (52)
	0x27, 0x45, 0x45, 0x45, 0x39,  // '5' (53)
	0x3C, 0x4A, 0x49, 0x49, 0x30,  // '6' (54)
	0x01, 0x71, 0x09, 0x05, 0x03,  // '7' (55)
	0x36, 0x49, 0x49, 0x49, 0x36,  // '8' (56)
	0x06, 0x49, 0x49, 0x29, 0x1E,  // '9' (57)
	
	// Símbolos ASCII 58-64
	0x00, 0x36, 0x36, 0x00, 0x00,  // ':' (58)
	0x00, 0x56, 0x36, 0x00, 0x00,  // ';' (59)
	0x08, 0x14, 0x22, 0x41, 0x00,  // '<' (60)
	0x14, 0x14, 0x14, 0x14, 0x14,  // '=' (61)
	0x00, 0x41, 0x22, 0x14, 0x08,  // '>' (62)
	0x02, 0x01, 0x51, 0x09, 0x06,  // '?' (63)
	0x32, 0x49, 0x79, 0x41, 0x3E,  // '@' (64)

	// Letras maiúsculas ASCII 65-90 ('A' - 'Z')
	0x7E, 0x11, 0x11, 0x11, 0x7E,  // 'A' (65)
	0x7F, 0x49, 0x49, 0x49, 0x36,  // 'B' (66)
	0x3E, 0x41, 0x41, 0x41, 0x22,  // 'C' (67)
	0x7F, 0x41, 0x41, 0x41, 0x3E,  // 'D' (68)
	0x7F, 0x49, 0x49, 0x49, 0x41,  // 'E' (69)
	0x7F, 0x09, 0x09, 0x09, 0x01,  // 'F' (70)
	0x3E, 0x41, 0x49, 0x49, 0x7A,  // 'G' (71)
	0x7F, 0x08, 0x08, 0x08, 0x7F,  // 'H' (72)
	0x00, 0x41, 0x7F, 0x41, 0x00,  // 'I' (73)
	0x20, 0x40, 0x41, 0x3F, 0x01,  // 'J' (74)
	0x7F, 0x08, 0x14, 0x22, 0x41,  // 'K' (75)
	0x7F, 0x40, 0x40, 0x40, 0x40,  // 'L' (76)
	0x7F, 0x02, 0x04, 0x02, 0x7F,  // 'M' (77)
	0x7F, 0x04, 0x08, 0x10, 0x7F,  // 'N' (78)
	0x3E, 0x41, 0x41, 0x41, 0x3E,  // 'O' (79)
	0x7F, 0x09, 0x09, 0x09, 0x06,  // 'P' (80)
	0x3E, 0x41, 0x51, 0x21, 0x5E,  // 'Q' (81)
	0x7F, 0x09, 0x19, 0x29, 0x46,  // 'R' (82)
	0x46, 0x49, 0x49, 0x49, 0x31,  // 'S' (83)
	0x01, 0x01, 0x7F, 0x01, 0x01,  // 'T' (84)
	0x3F, 0x40, 0x40, 0x40, 0x3F,  // 'U' (85)
	0x1F, 0x20, 0x40, 0x20, 0x1F,  // 'V' (86)
	0x7F, 0x40, 0x3F, 0x40, 0xF,  // 'W' (87)
	0x63, 0x14, 0x08, 0x14, 0x63,  // 'X' (88)
	0x07, 0x08, 0x70, 0x08, 0x07,  // 'Y' (89)
	0x61, 0x51, 0x49, 0x45, 0x43,  // 'Z' (90)

	// Símbolos ASCII 91-96 ('[' - '`')
	0x00, 0x7F, 0x41, 0x41, 0x00,  // '[' (91)
	0x02, 0x04, 0x08, 0x10, 0x20,  // '\' (92)
	0x00, 0x41, 0x41, 0x7F, 0x00,  // ']' (93)
	0x04, 0x02, 0x01, 0x02, 0x04,  // '^' (94)
	0x80, 0x80, 0x80, 0x80, 0x80,  // '_' (95)
	0x00, 0x03, 0x07, 0x00, 0x00,  // '`' (96)

	// Letras minúsculas ASCII 97-122 ('a' - 'z')
	0x20, 0x54, 0x54, 0x54, 0x78,  // 'a' (97)
	0x7F, 0x48, 0x44, 0x44, 0x38,  // 'b' (98)
	0x38, 0x44, 0x44, 0x44, 0x20,  // 'c' (99)
	0x38, 0x44, 0x44, 0x48, 0x7F,  // 'd' (100)
	0x38, 0x54, 0x54, 0x54, 0x18,  // 'e' (101)
	0x08, 0x7E, 0x09, 0x01, 0x02,  // 'f' (102)
	0x0C, 0x52, 0x52, 0x52, 0x3E,  // 'g' (103)
	0x7F, 0x08, 0x04, 0x04, 0x78,  // 'h' (104)
	0x00, 0x44, 0x7D, 0x40, 0x00,  // 'i' (105)
	0x20, 0x40, 0x44, 0x3D, 0x00,  // 'j' (106)
	0x7F, 0x10, 0x28, 0x44, 0x00,  // 'k' (107)
	0x00, 0x41, 0x7F, 0x40, 0x00,  // 'l' (108)
	0x7C, 0x04, 0x18, 0x04, 0x7C,  // 'm' (109)
	0x7C, 0x08, 0x04, 0x04, 0x78,  // 'n' (110)
	0x38, 0x44, 0x44, 0x44, 0x38,  // 'o' (111)
	0x7C, 0x14, 0x14, 0x14, 0x08,  // 'p' (112)
	0x08, 0x14, 0x14, 0x18, 0x7C,  // 'q' (113)
	0x7C, 0x08, 0x04, 0x04, 0x08,  // 'r' (114)
	0x48, 0x54, 0x54, 0x54, 0x20,  // 's' (115)
	0x04, 0x3F, 0x44, 0x40, 0x20,  // 't' (116)
	0x3C, 0x40, 0x40, 0x20, 0x7C,  // 'u' (117)
	0x1C, 0x20, 0x40, 0x20, 0x1C,  // 'v' (118)
	0x3C, 0x40, 0x30, 0x40, 0x3C,  // 'w' (119)
	0x44, 0x28, 0x10, 0x28, 0x44,  // 'x' (120)
	0x0C, 0x50, 0x50, 0x50, 0x3C,  // 'y' (121)
	0x44, 0x64, 0x54, 0x4C, 0x44,  // 'z' (122)

	// Símbolos ASCII 123-126 ('{' - '~')
	0x00, 0x08, 0x36, 0x41, 0x00,  // '{' (123)
	0x00, 0x00, 0x7F, 0x00, 0x00,  // '|' (124)
	0x00, 0x41, 0x36, 0x08, 0x00,  // '}' (125)
	0x08, 0x08, 0x2A, 0x1C, 0x08,  // '~' (126)
	
};

void sendData(uint8_t data) {
	i2c_start(OLED_ADDRESS);  // Inicia a comunicação I2C com o endereço do display
	i2c_write(0x40);                 // Byte de controle para indicar que é um dado
	i2c_write(data);                 // O dado a ser enviado
	i2c_stop();                      // Termina a comunicação I2C
}


void clearDisplay() {
	// Limpa a memória do display preenchendo com 0
	for (uint8_t page = 0; page < 8; page++) { // O display é dividido em 8 páginas
		setCursor(0, page); // Define o cursor na coluna 0 e na página atual

		// Envia 128 bytes de 0 (limpando a linha)
		for (uint8_t col = 0; col < 128; col++) {
			sendData(0x00); // Envia 0 para cada coluna da página
		}
	}
}


// Função para inicializar o I2C
void i2c_init(void) {
	TWSR = 0x00;                      // Configura o prescaler para 1
	TWBR = ((F_CPU / SCL_CLOCK) - 16) / 2;  // Configura a taxa de clock
	TWCR = (1 << TWEN);               // Habilita o I2C (TWI)
}

// Função para enviar o START
void i2c_start(void) {
	TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
	while (!(TWCR & (1 << TWINT)));  // Aguarda até que o start seja transmitido
}

// Função para enviar o STOP
void i2c_stop(void) {
	TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
	while (TWCR & (1 << TWSTO));  // Aguarda até que o stop seja transmitido
}

// Função para enviar um byte de dados
void i2c_write(uint8_t data) {
	TWDR = data;
	TWCR = (1 << TWINT) | (1 << TWEN);
	while (!(TWCR & (1 << TWINT)));  // Aguarda até que o byte seja transmitido
}

// Função para ler um byte de dados com ACK (acknowledge)
uint8_t i2c_read_ack(void) {
	TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
	while (!(TWCR & (1 << TWINT)));  // Aguarda até que o byte seja recebido
	return TWDR;
}

// Função para ler um byte de dados sem ACK (acknowledge)
uint8_t i2c_read_nack(void) {
	TWCR = (1 << TWINT) | (1 << TWEN);
	while (!(TWCR & (1 << TWINT)));  // Aguarda até que o byte seja recebido
	return TWDR;
}



void oled_command(uint8_t cmd) {
	i2c_start();
	i2c_write(OLED_ADDRESS << 1);  // Envia o endereço do OLED
	i2c_write(0x00);  // 0x00 indica que vamos enviar um comando
	i2c_write(cmd);   // Envia o comando
	i2c_stop();
}

void oled_init(void) {
	oled_command(0xAE);  // Desativa o display
	oled_command(0xD5);  // Configura o clock
	oled_command(0x80);  // Clock divisor
	oled_command(0xA8);  // Define a altura do display
	oled_command(0x3F);  // 63 linhas (altura para 128x64)
	oled_command(0xD3);  // Offset de exibição
	oled_command(0x00);  // Sem offset
	oled_command(0x40);  // Define o início da linha
	oled_command(0x8D);  // Habilita carga da bomba
	oled_command(0x14);  // Habilita a bomba
	oled_command(0x20);  // Modo de endereçamento
	oled_command(0x00);  // Endereçamento horizontal
	oled_command(0xA1);  // Orientação normal
	oled_command(0xC8);  // Mapeamento de linhas invertido
	oled_command(0xDA);  // Configuração do hardware
	oled_command(0x12);  // Alternância de pinos
	oled_command(0x81);  // Definir contraste
	oled_command(0x7F);  // Contraste médio
	oled_command(0xD9);  // Configuração de pré-carregamento
	oled_command(0xF1);
	oled_command(0xDB);  // Configuração de vcomh
	oled_command(0x40);
	oled_command(0xA4);  // Habilitar exibição
	oled_command(0xA6);  // Modo normal
	oled_command(0xAF);  // Liga o display
}

void oled_data(uint8_t data) {
	i2c_start();
	i2c_write(OLED_ADDRESS << 1);  // Endereço do display
	i2c_write(0x40);  // 0x40 indica que vamos enviar dados
	i2c_write(data);  // Envia o dado (um byte de gráfico)
	i2c_stop();
}

void sendCommand(uint8_t command) {
	// Função genérica para enviar comandos via I2C
	i2c_start();  // Inicia a comunicação I2C com o endereço do display
	i2c_write(0x00);                 // Byte de controle para indicar um comando
	i2c_write(command);              // O comando a ser enviado
	i2c_stop();                      // Termina a comunicação I2C
}


// Define o endereço do cursor (coluna e linha) no display OLED
void setCursor(uint8_t column, uint8_t row) {
	// O display SSD1306 tem 128 colunas e normalmente 8 páginas (cada uma com 8 linhas de pixels).
	// Esta função define a posição do cursor no display.
	
	// Define o endereço da coluna (de 0 a 127)
	sendCommand(0x21); // Comando para definir o intervalo de colunas
	sendCommand(column);  // Coluna inicial
	sendCommand(127);     // Coluna final (aqui limitamos a 127, mas pode ser ajustado)
	
	// Define o endereço da página (linha de 8 pixels)
	sendCommand(0x22); // Comando para definir o intervalo de páginas
	sendCommand(row);   // Página inicial (0-7)
	sendCommand(7);     // Página final (normalmente 7, depende do display)
}





